/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AcknowledgeObservation struct {
}

type AcknowledgeParameters struct {

	// +kubebuilder:validation:Optional
	Alias *string `json:"alias,omitempty" tf:"alias,omitempty"`

	// +kubebuilder:validation:Optional
	Filter []FilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Note *string `json:"note,omitempty" tf:"note,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type ActionObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ActionParameters struct {

	// +kubebuilder:validation:Optional
	Acknowledge []AcknowledgeParameters `json:"acknowledge,omitempty" tf:"acknowledge,omitempty"`

	// +kubebuilder:validation:Optional
	AddNote []AddNoteParameters `json:"addNote,omitempty" tf:"add_note,omitempty"`

	// +kubebuilder:validation:Optional
	Close []CloseParameters `json:"close,omitempty" tf:"close,omitempty"`

	// +kubebuilder:validation:Optional
	Create []CreateParameters `json:"create,omitempty" tf:"create,omitempty"`

	// +kubebuilder:validation:Optional
	Ignore []IgnoreParameters `json:"ignore,omitempty" tf:"ignore,omitempty"`

	// +kubebuilder:validation:Required
	IntegrationID *string `json:"integrationId" tf:"integration_id,omitempty"`
}

type AddNoteFilterObservation struct {
}

type AddNoteFilterParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []FilterConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type AddNoteObservation struct {
}

type AddNoteParameters struct {

	// +kubebuilder:validation:Optional
	Alias *string `json:"alias,omitempty" tf:"alias,omitempty"`

	// +kubebuilder:validation:Optional
	Filter []AddNoteFilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Note *string `json:"note,omitempty" tf:"note,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type CloseFilterConditionsObservation struct {
}

type CloseFilterConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type CloseFilterObservation struct {
}

type CloseFilterParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []CloseFilterConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type CloseObservation struct {
}

type CloseParameters struct {

	// +kubebuilder:validation:Optional
	Alias *string `json:"alias,omitempty" tf:"alias,omitempty"`

	// +kubebuilder:validation:Optional
	Filter []CloseFilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Note *string `json:"note,omitempty" tf:"note,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type ConditionsObservation struct {
}

type ConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type CreateFilterConditionsObservation struct {
}

type CreateFilterConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type CreateFilterObservation struct {
}

type CreateFilterParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []CreateFilterConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type CreateObservation struct {
}

type CreateParameters struct {

	// +kubebuilder:validation:Optional
	AlertActions []*string `json:"alertActions,omitempty" tf:"alert_actions,omitempty"`

	// +kubebuilder:validation:Optional
	Alias *string `json:"alias,omitempty" tf:"alias,omitempty"`

	// +kubebuilder:validation:Optional
	AppendAttachments *bool `json:"appendAttachments,omitempty" tf:"append_attachments,omitempty"`

	// +kubebuilder:validation:Optional
	CustomPriority *string `json:"customPriority,omitempty" tf:"custom_priority,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Entity *string `json:"entity,omitempty" tf:"entity,omitempty"`

	// +kubebuilder:validation:Optional
	ExtraProperties map[string]*string `json:"extraProperties,omitempty" tf:"extra_properties,omitempty"`

	// +kubebuilder:validation:Optional
	Filter []CreateFilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreAlertActionsFromPayload *bool `json:"ignoreAlertActionsFromPayload,omitempty" tf:"ignore_alert_actions_from_payload,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreExtraPropertiesFromPayload *bool `json:"ignoreExtraPropertiesFromPayload,omitempty" tf:"ignore_extra_properties_from_payload,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreRespondersFromPayload *bool `json:"ignoreRespondersFromPayload,omitempty" tf:"ignore_responders_from_payload,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreTagsFromPayload *bool `json:"ignoreTagsFromPayload,omitempty" tf:"ignore_tags_from_payload,omitempty"`

	// +kubebuilder:validation:Optional
	IgnoreTeamsFromPayload *bool `json:"ignoreTeamsFromPayload,omitempty" tf:"ignore_teams_from_payload,omitempty"`

	// +kubebuilder:validation:Optional
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Note *string `json:"note,omitempty" tf:"note,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *string `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	Responders []RespondersParameters `json:"responders,omitempty" tf:"responders,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	User *string `json:"user,omitempty" tf:"user,omitempty"`
}

type FilterConditionsObservation struct {
}

type FilterConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type FilterObservation struct {
}

type FilterParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type IgnoreFilterConditionsObservation struct {
}

type IgnoreFilterConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type IgnoreFilterObservation struct {
}

type IgnoreFilterParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []IgnoreFilterConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type IgnoreObservation struct {
}

type IgnoreParameters struct {

	// +kubebuilder:validation:Optional
	Filter []IgnoreFilterParameters `json:"filter,omitempty" tf:"filter,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RespondersObservation struct {
}

type RespondersParameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// ActionSpec defines the desired state of Action
type ActionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ActionParameters `json:"forProvider"`
}

// ActionStatus defines the observed state of Action.
type ActionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ActionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Action is the Schema for the Actions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,opsgenie-providerjet}
type Action struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ActionSpec   `json:"spec"`
	Status            ActionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ActionList contains a list of Actions
type ActionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Action `json:"items"`
}

// Repository type metadata.
var (
	Action_Kind             = "Action"
	Action_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Action_Kind}.String()
	Action_KindAPIVersion   = Action_Kind + "." + CRDGroupVersion.String()
	Action_GroupVersionKind = CRDGroupVersion.WithKind(Action_Kind)
)

func init() {
	SchemeBuilder.Register(&Action{}, &ActionList{})
}
