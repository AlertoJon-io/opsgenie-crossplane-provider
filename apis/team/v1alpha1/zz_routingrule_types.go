/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConditionsObservation struct {
}

type ConditionsParameters struct {

	// +kubebuilder:validation:Optional
	ExpectedValue *string `json:"expectedValue,omitempty" tf:"expected_value,omitempty"`

	// +kubebuilder:validation:Required
	Field *string `json:"field" tf:"field,omitempty"`

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Not *bool `json:"not,omitempty" tf:"not,omitempty"`

	// +kubebuilder:validation:Required
	Operation *string `json:"operation" tf:"operation,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`
}

type CriteriaObservation struct {
}

type CriteriaParameters struct {

	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type NotifyObservation struct {
}

type NotifyParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RestrictionObservation struct {
}

type RestrictionParameters struct {

	// +kubebuilder:validation:Required
	EndHour *float64 `json:"endHour" tf:"end_hour,omitempty"`

	// +kubebuilder:validation:Required
	EndMin *float64 `json:"endMin" tf:"end_min,omitempty"`

	// +kubebuilder:validation:Required
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// +kubebuilder:validation:Required
	StartMin *float64 `json:"startMin" tf:"start_min,omitempty"`
}

type RestrictionsObservation struct {
}

type RestrictionsParameters struct {

	// +kubebuilder:validation:Required
	EndDay *string `json:"endDay" tf:"end_day,omitempty"`

	// +kubebuilder:validation:Required
	EndHour *float64 `json:"endHour" tf:"end_hour,omitempty"`

	// +kubebuilder:validation:Required
	EndMin *float64 `json:"endMin" tf:"end_min,omitempty"`

	// +kubebuilder:validation:Required
	StartDay *string `json:"startDay" tf:"start_day,omitempty"`

	// +kubebuilder:validation:Required
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// +kubebuilder:validation:Required
	StartMin *float64 `json:"startMin" tf:"start_min,omitempty"`
}

type RoutingRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RoutingRuleParameters struct {

	// +kubebuilder:validation:Optional
	Criteria []CriteriaParameters `json:"criteria,omitempty" tf:"criteria,omitempty"`

	// +kubebuilder:validation:Optional
	IsDefault *bool `json:"isDefault,omitempty" tf:"is_default,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Notify []NotifyParameters `json:"notify" tf:"notify,omitempty"`

	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// +kubebuilder:validation:Required
	TeamID *string `json:"teamId" tf:"team_id,omitempty"`

	// +kubebuilder:validation:Optional
	TimeRestriction []TimeRestrictionParameters `json:"timeRestriction,omitempty" tf:"time_restriction,omitempty"`

	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone,omitempty"`
}

type TimeRestrictionObservation struct {
}

type TimeRestrictionParameters struct {

	// +kubebuilder:validation:Optional
	Restriction []RestrictionParameters `json:"restriction,omitempty" tf:"restriction,omitempty"`

	// +kubebuilder:validation:Optional
	Restrictions []RestrictionsParameters `json:"restrictions,omitempty" tf:"restrictions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// RoutingRuleSpec defines the desired state of RoutingRule
type RoutingRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RoutingRuleParameters `json:"forProvider"`
}

// RoutingRuleStatus defines the observed state of RoutingRule.
type RoutingRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RoutingRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RoutingRule is the Schema for the RoutingRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,opsgenie-providerjet}
type RoutingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RoutingRuleSpec   `json:"spec"`
	Status            RoutingRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RoutingRuleList contains a list of RoutingRules
type RoutingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RoutingRule `json:"items"`
}

// Repository type metadata.
var (
	RoutingRule_Kind             = "RoutingRule"
	RoutingRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RoutingRule_Kind}.String()
	RoutingRule_KindAPIVersion   = RoutingRule_Kind + "." + CRDGroupVersion.String()
	RoutingRule_GroupVersionKind = CRDGroupVersion.WithKind(RoutingRule_Kind)
)

func init() {
	SchemeBuilder.Register(&RoutingRule{}, &RoutingRuleList{})
}
