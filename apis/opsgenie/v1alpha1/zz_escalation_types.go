/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type EscalationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type EscalationParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	OwnerTeamID *string `json:"ownerTeamId,omitempty" tf:"owner_team_id,omitempty"`

	// +kubebuilder:validation:Optional
	Repeat []RepeatParameters `json:"repeat,omitempty" tf:"repeat,omitempty"`

	// +kubebuilder:validation:Required
	Rules []RulesParameters `json:"rules" tf:"rules,omitempty"`
}

type RecipientObservation struct {
}

type RecipientParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RepeatObservation struct {
}

type RepeatParameters struct {

	// +kubebuilder:validation:Optional
	CloseAlertAfterAll *bool `json:"closeAlertAfterAll,omitempty" tf:"close_alert_after_all,omitempty"`

	// +kubebuilder:validation:Optional
	Count *float64 `json:"count,omitempty" tf:"count,omitempty"`

	// +kubebuilder:validation:Optional
	ResetRecipientStates *bool `json:"resetRecipientStates,omitempty" tf:"reset_recipient_states,omitempty"`

	// +kubebuilder:validation:Optional
	WaitInterval *float64 `json:"waitInterval,omitempty" tf:"wait_interval,omitempty"`
}

type RulesObservation struct {
}

type RulesParameters struct {

	// +kubebuilder:validation:Required
	Condition *string `json:"condition" tf:"condition,omitempty"`

	// +kubebuilder:validation:Required
	Delay *float64 `json:"delay" tf:"delay,omitempty"`

	// +kubebuilder:validation:Required
	NotifyType *string `json:"notifyType" tf:"notify_type,omitempty"`

	// +kubebuilder:validation:Required
	Recipient []RecipientParameters `json:"recipient" tf:"recipient,omitempty"`
}

// EscalationSpec defines the desired state of Escalation
type EscalationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EscalationParameters `json:"forProvider"`
}

// EscalationStatus defines the observed state of Escalation.
type EscalationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EscalationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Escalation is the Schema for the Escalations API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,opsgenie-providerjet}
type Escalation struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EscalationSpec   `json:"spec"`
	Status            EscalationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EscalationList contains a list of Escalations
type EscalationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Escalation `json:"items"`
}

// Repository type metadata.
var (
	Escalation_Kind             = "Escalation"
	Escalation_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Escalation_Kind}.String()
	Escalation_KindAPIVersion   = Escalation_Kind + "." + CRDGroupVersion.String()
	Escalation_GroupVersionKind = CRDGroupVersion.WithKind(Escalation_Kind)
)

func init() {
	SchemeBuilder.Register(&Escalation{}, &EscalationList{})
}
