/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ParticipantObservation struct {
}

type ParticipantParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RestrictionObservation struct {
}

type RestrictionParameters struct {

	// +kubebuilder:validation:Required
	EndHour *float64 `json:"endHour" tf:"end_hour,omitempty"`

	// +kubebuilder:validation:Required
	EndMin *float64 `json:"endMin" tf:"end_min,omitempty"`

	// +kubebuilder:validation:Required
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// +kubebuilder:validation:Required
	StartMin *float64 `json:"startMin" tf:"start_min,omitempty"`
}

type RestrictionsObservation struct {
}

type RestrictionsParameters struct {

	// +kubebuilder:validation:Required
	EndDay *string `json:"endDay" tf:"end_day,omitempty"`

	// +kubebuilder:validation:Required
	EndHour *float64 `json:"endHour" tf:"end_hour,omitempty"`

	// +kubebuilder:validation:Required
	EndMin *float64 `json:"endMin" tf:"end_min,omitempty"`

	// +kubebuilder:validation:Required
	StartDay *string `json:"startDay" tf:"start_day,omitempty"`

	// +kubebuilder:validation:Required
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// +kubebuilder:validation:Required
	StartMin *float64 `json:"startMin" tf:"start_min,omitempty"`
}

type RotationObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RotationParameters struct {

	// +kubebuilder:validation:Optional
	EndDate *string `json:"endDate,omitempty" tf:"end_date,omitempty"`

	// +kubebuilder:validation:Optional
	Length *float64 `json:"length,omitempty" tf:"length,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Participant []ParticipantParameters `json:"participant" tf:"participant,omitempty"`

	// +kubebuilder:validation:Required
	ScheduleID *string `json:"scheduleId" tf:"schedule_id,omitempty"`

	// +kubebuilder:validation:Required
	StartDate *string `json:"startDate" tf:"start_date,omitempty"`

	// +kubebuilder:validation:Optional
	TimeRestriction []TimeRestrictionParameters `json:"timeRestriction,omitempty" tf:"time_restriction,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type TimeRestrictionObservation struct {
}

type TimeRestrictionParameters struct {

	// +kubebuilder:validation:Optional
	Restriction []RestrictionParameters `json:"restriction,omitempty" tf:"restriction,omitempty"`

	// +kubebuilder:validation:Optional
	Restrictions []RestrictionsParameters `json:"restrictions,omitempty" tf:"restrictions,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// RotationSpec defines the desired state of Rotation
type RotationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RotationParameters `json:"forProvider"`
}

// RotationStatus defines the observed state of Rotation.
type RotationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RotationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Rotation is the Schema for the Rotations API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,opsgenie-providerjet}
type Rotation struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RotationSpec   `json:"spec"`
	Status            RotationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RotationList contains a list of Rotations
type RotationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Rotation `json:"items"`
}

// Repository type metadata.
var (
	Rotation_Kind             = "Rotation"
	Rotation_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Rotation_Kind}.String()
	Rotation_KindAPIVersion   = Rotation_Kind + "." + CRDGroupVersion.String()
	Rotation_GroupVersionKind = CRDGroupVersion.WithKind(Rotation_Kind)
)

func init() {
	SchemeBuilder.Register(&Rotation{}, &RotationList{})
}
